//
//  main.cpp
//  fuckyou!!!!
//
//  Created by BRabbit on 16/5/24.
//  Copyright © 2016年 IUBCS. All rights reserved.
//
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;

typedef struct node{
    int data;
    node *next;
}node;


node* intial(int a[], int n)
{
    node *head, *p;
    int i;
    for(i = 0; i<n; i++)
    {
        node *nd = new node();
        nd->data = a[i];
        if(i == 0)
        {
            head = p = nd;
            continue;
        }
        p->next = nd;
        p = nd;
    }
    return head;
}

node* deleduplicate1(node *head, bool hash[])
{
    node *p = head, *q = head->next;
    hash[head->data] = true;
    while(q)
    {
        if(hash[q->data]==true)
        {
            //node *t = q; //可能根据编译器的不同这句可能会需要。 但是这里不需要。
            p->next = q->next;
            q = p->next;
            //delete t;
        }
        else
        {
            hash[q->data] = true;
            p = q;
            q = q->next;
        }
    }
    return head;
}

void deleduplicate2(node *head)
{
    node *p, *move1, *move2;
    p = head;
    while(p)
    {
        int nd = p->data;
        move1 = p;
        move2 = p->next;
        while(move2)
        {
            if(move2->data == nd)
            {
                move1->next = move2->next;
                move2 = move1->next;
            }
            else
            {
                move1 = move2;
                move2 = move2->next;
            }
        }
            
        p = p->next;
    }
    
}



int main()
{
    int n = 5;
    int a[] = {2,3,10,10,4};
    node *head = intial(a, n);
    bool hash[100];
    memset(hash, false, sizeof(hash));
    deleduplicate2(head);
    
    while(head)
    {
        cout<<head->data<<endl;
        head = head->next;
    }
    
//    node *try1 = new node();
//    try1->data = 100;
//    node *try2 = try1;
//    delete try2;
//    cout<<&(try1->data)<<endl;
    //deleduplicate2(head);
    //print(head);
    return 0;
}


