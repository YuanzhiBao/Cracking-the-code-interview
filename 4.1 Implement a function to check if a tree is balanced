#include <iostream>
#include <cstring> //memset 必须要用这个头文件
#include <cmath>
using namespace std;

const int maxn = 100;
struct Node{
	int key;
	Node *lchild, *rchild, *parent;
};
Node *head, *p, node[maxn];
int cnt;

void init(){
	head = p = NULL;
	memset(node, '\0', sizeof(node));
	cnt = 0;
}
void insert(Node* &head, int x){// 之所以要传&进去是因为这个是结构体，结构体指针当然可以只传指针进去，但是要传结构体就必须
                                //要传地址进去，这是结构体的特点。 想象一下，如果只传指针进去，内存不知道该分配多少
                                //内存到函数里。 
                                //另外，非常重要，即使head是全局变量，但是只要函数调用了，在函数里面他就不是原来的head了
                                //这点不是很懂，但是使用的时候要主要，别用错了。
	if(head == NULL){
		node[cnt].key = x;
		node[cnt].parent = p;
		head = &node[cnt++];
		return;
	}
	p = head;
	if(x < head->key)
		insert(head->lchild, x);
	else
		insert(head->rchild, x);
}
int d = 0, num = 0, dep[maxn];
void getDepth(Node *head){
	if(head == NULL) return;
	++d;
	getDepth(head->lchild);
	if(head->lchild == NULL && head->rchild == NULL)
		dep[num++] = d;
	getDepth(head->rchild);
	--d;
}
bool isBalance(Node *head){
	if(head == NULL) return true;
	getDepth(head);
	int max = dep[0], min = dep[0];
	for(int i=0; i<num; ++i){
		if(dep[i]>max) max = dep[i];
		if(dep[i]<min) min = dep[i];
	}
	if(max-min > 1) return false;
	else return true;
}
int main(){
	init();
	int a[] = {
		5, 3, 8, 1, 4, 7, 10, 2, 6, 9, 11, 12
	};
	for(int i=0; i<12; ++i)
		insert(head, a[i]);
	cout<<isBalance(head)<<endl;
	return 0;
}
